# 第二章。理解网络概念

在开始编写网络应用程序之前，我们最好先了解一下网络是如何工作的。在本章中，我们将挖掘网络概念及其内容。我们将在本章中讨论的主题如下:

*   区分现场视察模型和传输控制协议模型
*   探索 IPv4 和 IPv6 中的 IP 地址
*   使用各种工具排除 TCP/IP 问题

# 网络系统介绍

网络架构由层和协议构成。架构中的每一个 **层**都有自己的角色，而其主要目的是为更高层提供一定的服务，并与相邻层进行的沟通。然而，**协议**是所有通信方用来标准化通信过程的规则和约定的集合。例如，当一个设备中的层 *n* 与另一个设备中的另一层 *n* 通信时，为了进行通信，它们必须使用相同的协议。

现在流行的网络架构有两种:**开放系统互连** ( **OSI** )和 **TCP/IP** 参考模型。我们将更深入地了解每个参考模型及其优缺点，以便决定在我们的网络应用中应该使用哪个模型。

## 现场视察参考模型

OSI 模型用于连接到开放的系统——这些系统是开放的，并与其他系统通信。通过使用这种模型，我们不再依赖于操作系统，因此我们可以与任何计算机上的任何操作系统进行通信。该模型包含七层，每层都有特定的功能，并定义了在某些不同的层上处理数据的方式。该模型包含的七层是 **物理层****数据链路层****网络层****传输层****会话层****表示层**应用层**。**

 **### 物理层

这是 OSI 模型中的第一个层，包含网络物理规范的定义，包括物理介质(电缆和连接器)和基本设备(中继器和集线器)。该层负责将输入的原始比特传输数据流转换成 0，并负责通信信道上的 1。然后，它将数据放在物理介质上。它关注数据传输的完整性，并确保从一台设备发送的位与另一台设备接收的数据完全相同。

### 数据链路层

数据链路层的主要作用是为原始数据传输提供链路。在传输数据之前，数据被分解成数据帧，数据链路层连续传输这些数据帧。如果服务可靠，接收器将为每个已发送的帧发回一个*确认帧*。

该层由两个子层组成:**逻辑链路控制** ( **LLC** )和**媒体访问控制** ( **MAC** )。LLC 子层负责传输错误检查并处理帧传输，而MAC 子层定义如何从物理介质中检索数据或将数据存储在物理介质中。

我们还可以在这一层找到 MAC 地址，也称为**物理地址**。媒体访问控制地址用于识别连接到网络的每个设备，因为它对每个设备都是唯一的。使用命令提示符，我们可以通过在控制台窗口中键入以下命令来获取地址:

```
ipconfig /all

```

在忽略除 **Windows IP 配置**和**无线局域网适配器 Wi-Fi** 以外的所有其他信息后，我们将获得控制台输出，如下所示。我们可以在**物理地址**部分找到 MAC 地址，我自己的环境是 **80-19-34-CB-BF-FB** 。您将获得不同的结果，因为每个设备的 MAC 地址都是唯一的:

```
Windows IP Configuration

 Host Name . . . . . . . . . . . . : HOST1
 Primary Dns Suffix  . . . . . . . :
 Node Type . . . . . . . . . . . . : Hybrid
 IP Routing Enabled. . . . . . . . : No
 WINS Proxy Enabled. . . . . . . . : No

Wireless LAN adapter Wi-Fi:
 Connection-specific DNS Suffix  . :
 Description . . . . . . . . . . . : Intel(R) Wireless-N 7260
 Physical Address. . . . . . . . . : 80-19-34-CB-BF-FB
 DHCP Enabled. . . . . . . . . . . : Yes
 Autoconfiguration Enabled . . . . : Yes
 Link-local IPv6 Address . . . . . : fe80::f14e:d5e6:aa0a:5855%3 (Preferred)
 IPv4 Address. . . . . . . . . . . : 192.168.1.4(Preferred)
 Subnet Mask . . . . . . . . . . . : 255.255.255.0
 Default Gateway . . . . . . . . . : 192.168.1.254
 DHCP Server . . . . . . . . . . . : 192.168.1.254
 DHCPv6 IAID . . . . . . . . . . . : 58726708
 DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-1C-89-E6-3E-68-F7- 28-1E-61-66
 DNS Servers . . . . . . . . . . . : 192.168.1.254
 NetBIOS over Tcpip. . . . . . . . : Enabled

```

媒体访问控制地址包含 12 个十六进制字符，其中两位数字相互配对。前六位数字代表**组织唯一标识符**，其余数字代表**制造商序列号**。如果你真的很想知道这个号码是什么意思，可以去[www.macvendorlookup.com](http://www.macvendorlookup.com)把我们的 MAC 地址填入文本框，了解更多。在我自己的系统中，我获得了英特尔公司作为供应商公司名称，这与我安装的网卡的品牌相同。

### 网络层

网络层负责定义将数据包从源设备路由到目的设备的最佳方式。它将使用**互联网协议** ( **IP** )作为路由协议生成路由表，该 IP 地址用于确保数据到达所需目的地的路由。现在的 IP 有两个版本: **IPv4** 和 **IPv6** 。在 IPv4 中，我们使用 32 位地址来寻址协议，在 IPv6 中，我们使用 128 位地址。在下一个主题中，您将了解有关互联网协议、IPv4 和 IPv6 的更多信息。

### 传输层

传输层负责将数据从源传输到目的地。它会将数据分成更小的部分，或者在这种情况下是**段**，然后将所有段连接起来，将数据恢复到其在目的地的初始形式。

工作在这一层的主要协议有两个:**传输控制协议** ( **TCP** )和**用户数据报协议** ( **UDP** )。TCP 通过建立会话来提供数据传输。在建立会话之前，不会传输数据。TCP 也被称为**面向连接的协议**，这意味着在传输数据之前必须建立会话。UDP 是一种尽最大努力传递数据的方法，但它不能保证传递，因为它不能建立会话。因此，UDP 也被称为**无连接协议**。关于 TCP 和 UDP 的深入解释可以在下一个主题中找到。

### 会话层

会话层负责会话的建立、维护和终止。我们可以将会话类比为网络上两个设备之间的连接。例如，如果我们想将一个文件从一台计算机发送到另一台计算机，在发送文件之前，该层将首先建立连接。然后，这一层将确保连接仍然正常，直到文件完全发送。最后，如果不再需要，该层将终止连接。我们谈论的联系是会话。

该层还确保来自不同应用程序的数据不会互换。例如，如果我们同时运行互联网浏览器、聊天应用程序和下载管理器，该层将负责为每个应用程序建立会话，并确保它们与其他应用程序保持分离。

该层使用三种通信方法:**单工**、**半双工**或**全双工**方法。在单纯形法中，数据只能由一方传输，因此另一方不能传输任何数据。这种方法不再普遍使用，因为我们需要可以相互交互的应用程序。在半双工方法中，任何数据都可以传输到所有相关设备，但在完成发送过程后，一次只能有一台设备传输数据。然后，其他人也可以发送和传输数据。全双工方法可以同时向所有设备传输数据。为了发送和接收数据，该方法使用不同的路径。

### 表示层

呈现层角色用于确定已经发送的数据，将数据翻译成合适的格式，然后呈现。例如，我们通过网络发送一个 MP3 文件，该文件被分成几个部分。然后，使用段上的头信息，该层将通过翻译段来构建文件。

此外，该层负责数据压缩和解压缩，因为通过互联网传输的所有数据都被压缩以节省带宽。该层还负责数据的加密和解密，以保证两台设备之间的通信安全。

### 应用层

应用层处理用户使用的计算机应用。只有连接到网络的应用程序才会连接到该层。该层包含用户需要的几种协议，如下所示:

*   **域名系统** ( **域名系统**):该协议是找到一个 IP 地址的主机名的协议。有了这个系统，我们不再需要记住每个 IP 地址，只需要记住主机名。我们很容易记住主机名中的一个单词，而不是 IP 地址中的一堆数字。
*   **超文本传输协议** ( **HTTP** ):该协议是通过互联网在网页上传输数据的协议。我们还有 HTTPS 格式，用于发送安全问题的加密数据。
*   **文件传输协议** ( **文件传输协议**):该协议用于将文件从文件传输协议服务器传输到文件传输协议服务器。
*   **琐碎的 FTP** ( **TFTP** ):这个协议类似于 FTP，用来发送更小的文件。
*   **动态主机配置协议** ( **DHCP** ):该协议是动态分配 TCP/IP 配置的方法。
*   **邮局协议** ( **POP3** ):该协议是一个电子邮件协议用于从 POP3 服务器上取回电子邮件。服务器通常由**互联网服务提供商** ( **互联网服务提供商**)托管。
*   **简单邮件传输协议** ( **SMTP** ):该协议与 POP3 形成对比，用于发送电子邮件。
*   **互联网消息访问协议** ( **IMAP** ):该协议用于接收电子邮件消息。有了这个协议，用户可以将他们的电子邮件保存在本地计算机的文件夹中。
*   **简单网络管理协议** ( **SNMP** ):该协议用于管理网络设备(路由器和交换机)发现问题并在问题变得严重之前进行报告。
*   **服务器消息块** ( **中小企业**):该协议是一种文件传输协议，在微软网络上主要用于文件和打印机共享。

该层还决定是否有足够的网络资源可用于网络访问。例如，如果您想使用互联网浏览器上网，应用层决定是否可以使用 HTTP 访问互联网。

让我们看下图来看看 OSI 层包括哪些协议:

![The Application layer](../images/00011.jpeg)

我们可以把这七层都分成两段层:**上层**和**下层**。上层负责与用户交互，不太关心底层细节，而下层负责通过网络传输数据，如格式化和编码。

数据传输的格式因层而异。物理层有位，数据链路层有帧，等等。

## TCP/IP 参考模型

TCP/IP 模型是在 OSI 模型之前创建的。该模型的工作方式类似于现场视察模型，只是它只包含四层。TCP/IP 模型上的每一层都对应于现场视察模型的各层。TCP/IP 应用层映射了现场视察模型的 5 层、6 层和 7 层。传输控制协议传输层映射现场视察模型的第 4 层。TCP/IP 互联网层映射了现场视察模型的第 3 层。TCP/IP 链路层映射了现场视察模型的第 1 层和第 2 层。让我们看下图了解更多细节:

![The TCP/IP reference model](../images/00012.jpeg)

这些是 TCP/IP 模型中每一层的主要角色:

*   链路层负责确定数据传输过程中使用的协议和物理设备。
*   互联网层负责通过寻址数据包来确定数据传输过程的最佳路由。
*   传输层负责建立两台设备之间的通信并发送数据包。
*   应用层负责向运行在计算机上的应用程序提供服务。由于缺少会话和演示层，应用程序必须包含在任何所需的会话和演示功能中。

以下是 TCP/IP 模型中涉及的协议和设备:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

层

 | 

草案

 | 

设备

 |
| --- | --- | --- |
| 应用 | HTTP、HTTPS、SMTP、POP3 和 DNS | 代理服务器和防火墙 |
| 运输 | TCP 和 UDP | - |
| 互联网 | IP 和 ICMP | 路由器 |
| 环 | 以太网、令牌环网和帧中继 | 集线器、调制解调器和中继器 |

# 了解 TCP 和 UDP

正如我们在本章前面的*传输层*一节中所讨论的，TCP 和 UDP 是用于通过网络传输数据的主要协议。它们的传递机制各不相同。TCP 在传输数据过程中有确认、序列号和流量控制，以提供有保证的传递，而 UDP 不提供有保证的传递，而是尽最大努力提供传递。

## 传输控制协议

在协议建立会话之前，TCP 执行三方握手过程。这样做是为了保证交货。请参考下图了解三向握手过程:

![Transmission Control Protocol](../images/00013.jpeg)

从上图中，假设卡罗尔的设备想要向布莱恩的设备传输数据，并且他们需要执行三方握手过程。首先，卡罗尔的设备向布莱恩的设备发送一个数据包，并启用**同步** ( **同步**)标志。一旦布莱恩的设备接收到数据包，它将通过发送另一个同时启用了同步和确认标志的数据包来回复。最后，卡罗尔的设备通过发送启用确认标志的第三个数据包来完成握手过程。现在，两个设备都建立了会话，并保证另一个设备正在工作。然后，在会话建立后，数据传输准备就绪。

### 类型

在安全领域，我们知道术语“SYN-Flood”，这是一种拒绝服务攻击，攻击者向目标系统发送一连串 SYN 请求，试图消耗足够的服务器资源，使系统对合法流量无响应。攻击者只是发送同步，而没有发送预期的确认，导致服务器将同步确认发送到一个伪造的 IP 地址，该地址不会发送确认，因为它“知道”它从未发送过同步。

TCP 还将数据分割成更小的数据段，并使用序列号来跟踪这些数据段。每个分离的段被分配不同的序列号，例如 1 到 20。然后，目标设备接收每个数据段，并使用序列号根据序列的顺序重组文件。

例如，考虑卡罗尔想要从布莱恩的设备下载一个 JPEG 图像文件。在三方握手过程中建立会话后，两台设备确定单个数据段有多大，以及在确认之间需要发送多少数据段。一次可以发送的段的总数称为 TCP **滑动窗口**。如果在传输中有一个位被破坏或丢失，该段中的数据将不再有效。TCP 使用**循环冗余** **检查** ( **CRC** )通过验证每个数据段中的数据是否完整来识别损坏或丢失的数据。如果传输中有损坏或丢失的段，卡罗尔的设备将发送**否定确认** ( **NACK** )数据包，然后请求损坏或丢失的段；否则，Carol 的设备将发送 ACK 数据包并请求下一个数据段。

## 用户数据报协议

UDP 在发送数据之前不执行任何握手过程。它只是将数据直接发送到目的设备；但是，它会尽最大努力转发消息。想象一下，我们正在等待朋友的消息。我们打他/她的电话来接收我们的信息。如果我们的电话没有被接听，我们可以发送电子邮件或短信通知我们的朋友。如果我们的朋友不回复我们的电子邮件或短信，我们可以定期发送电子邮件。然而，我们谈到的所有技术都不能保证我们的信息被接收到。但是，我们仍然尽最大努力转发这条信息，直到它起作用。这是我们发送电子邮件的最大努力类比，类似于 UDP 的最大努力术语。它将尽最大努力确保数据被接收方接收，即使不能保证数据被接收。

那么，为什么即使不可靠也要用 UDP 呢？有时，我们需要一种高速数据传输的通信，即使有一点数据损坏。例如，流式音频、流式视频和**IP 语音** ( **VoIP** )使用 UDP 来确保数据传输速度快。尽管 UDP 肯定丢失了数据包，但我们仍然能够清楚地获得所有消息。

然而，尽管 UDP 在传输数据之前不检查连接，但它实际上使用校验和来验证数据。校验和可以通过比较校验和值来检查接收的数据是否被改变。

## 了解港口

在计算机网络中，**端口**是发送或接收数据的端点。端口通过其包含 16 位数字的**端口号**来识别。TCP 和 UDP 都使用逻辑端口号来跟踪数据包的内容，并帮助 TCP/IP 获得应用程序或服务的数据包，当设备接收到该数据包时，该数据包将处理该数据。

共有`65536` TCP 端口和`65536` UDP 端口。我们可以将 TCP 端口分为三个端口范围，它们是:

*   从`0`到`1023`的知名端口是已经通过**互联网** **指定号码授权** ( **IANA** )注册的端口，用于与特定协议或应用相关联。
*   从`1024`到`49151`的注册端口是 IANA 已经为特定协议注册的端口，但是该范围内未使用的端口可以由计算机应用程序分配。
*   从`49152`到`65535`的动态端口是未注册的端口，可以为任何目的分配。

### 注

要了解更多关于 TCP 和 UDP 中所有端口的详细信息，我们可以去[en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)。还有，想知道所有 IANA 注册的指定港口，去[www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)。

为了理解端口概念，假设我们的计算机中安装了一个电子邮件客户端，例如雷鸟或微软 Outlook。现在，我们想向 Gmail 服务器发送一封电子邮件，然后从服务器获取所有传入的电子邮件，并将其保存在本地计算机上。发送电子邮件的步骤如下:

1.  我们的电脑会随机分配一个未使用的端口号，如`48127`，将邮件发送到 Gmail SMTP 服务器的端口`25`。
2.  当电子邮件到达 SMTP 服务器时，它识别出数据来自端口`25`，然后将数据转发给处理服务的 SMTP。
3.  一旦收到电子邮件，服务器将确认发送到我们计算机中的端口`48127`，通知计算机电子邮件已经收到。
4.  我们的电脑从端口`48127`完全收到确认后，会向邮件客户端发送一封邮件，邮件客户端再将邮件从发件箱移动到“已发送”文件夹。

类似于发送电子邮件的步骤，要接收电子邮件，我们必须处理一个端口。其步骤如下:

1.  我们的电脑会随机分配一个未使用的端口号，比如`48128`，向 Gmail POP3 服务器发送请求到端口`110`。
2.  当电子邮件到达 POP3 服务器时，它识别出数据来自端口`110`，然后将数据转发给处理服务的 POP3。
3.  然后，POP3 服务器通过端口`48128`向我们的计算机发送一封电子邮件。
4.  我们的电脑收到来自端口`48128`的邮件后，会将邮件发送到我们的邮件客户端，然后移动到收件箱文件夹。它还会自动将邮件保存到本地计算机。

# 探索互联网协议

IP 是一种主要的通信协议，用于通过网络传送数据报。数据报本身是与分组交换网络相关联的传输单元。IP 的作用是根据 IP 地址将数据包从主机传送到主机，IP 地址在数据包的报头中说明。现在常用的 IP 有两个版本，分别是 IPv4 和 IPv6。

## 互联网协议版本 4–IP v4

自 20 世纪 80 年代以来，IPv4 已经成为标准的 IP 地址，用于通过网络获取从一台计算机到另一台计算机的 TCP/IP 流量。对于通过互联网连接的每台设备，IP 地址都是唯一的，所有设备只要拥有有效的 IP 地址，就可以通过互联网相互通信。

一个有效的 IP 地址由四个十进制数构成，用三个点隔开。地址只包含从`0`到`255`的十进制数。我们可以说`10.161.4.25`是一个有效的 IP 地址，因为它包含在`0`到`255`之间的四个十进制数，并且用三个点隔开，而`192.2.256.4`是一个无效的 IP 地址，因为它包含大于`255`的十进制数。

十进制数字实际上是从 8 个二进制数字转换而来的结果。所以，对于最大的 8 位数字，我们将有 1111 1111 或 255 个十进制数。这就是为什么 IP 地址中十进制数的范围是从 0 (0000 0000)到 255 (1111 1111)。

要了解我们的 IP 地址配置，我们可以在命令提示符窗口中再次使用`ipconfig /all`命令。然后，它将显示如下输出:

```
Wireless LAN adapter Wi-Fi:
 Connection-specific DNS Suffix  . :
 Link-local IPv6 Address . . . . . : fe80::f14e:d5e6:aa0a:5855%3
 IPv4 Address. . . . . . . . . . . : 10.1.6.165
 Subnet Mask . . . . . . . . . . . : 255.255.255.0
 Default Gateway . . . . . . . . . : 10.1.6.1

```

输出将显示 IPv4 地址和 IPv6 地址中的 IP 地址。我们还可以看到，在我的设备中，`10.1.6.1`被用作系统的默认网关。`Default Gateway`参数是计算机网络上的一个点，用于为不匹配的 IP 地址或子网提供路径。

一个 IP 地址必须包含这两个部分:一个**网络标识**来标识计算机所在的子网，一个**主机标识**来标识该子网内的计算机。每个网络标识表示网络子网中的一组主机。具有相同网络标识的设备必须具有唯一的主机标识。如果两台或多台设备具有相同的主机标识和相同的网络标识(所有四个十进制数字的 IP 地址都相同)，则会出现 IP 地址冲突。

对于本地网络，**子网掩码**用于标识网络标识和主机标识在 IP 地址中的部分。以下是一些常见的子网掩码:

*   `255.0.0.0`
*   `255.255.0.0`
*   `255.255.255.0`

假设我们有 IP 地址`190.23.4.51`和子网掩码`255.255.0.0`。现在，我们可以使用布尔`AND`逻辑为子网掩码对应的 IP 地址的每一位找到网络标识。下表将 IP 地址和子网掩码转换为二进制数字，然后使用布尔`AND`逻辑找出网络标识:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
|   | 

第 1 个字节

 | 

第二个字节

 | 

3 个字节

 | 

八月四日

 |
| --- | --- | --- | --- | --- |
| 190.23.4.51 | 1011 1110 | 0001 0111 | 0000 0100 | 0011 0011 |
| 255.255.0.0 | 1111 1111 | 1111 1111 | 0000 0000 | 0000 0000 |
| **网络 ID:** | 1011 1110 | 0001 0111 | 0000 0000 | 0000 0000 |

从上表我们可以得到网络 ID，为`190.23.0.0`。

子网掩码中必须应用相邻的最大数量。这意味着，如果决定使用第一个零，其余的数字必须为零。所以`255.0.255.0`的子网掩码无效。子网掩码也不允许以零开头。这意味着`0.255.0.0`的子网掩码也无效。

IPv4 可以分为三个主要地址类别:A 类、B 类和 c 类。地址的类别由 IP 地址中的第一个数字定义，子网掩码是为每个类别预定义的。以下是每个类别的三个范围:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

班级

 | 

第一个数字

 | 

IP 地址的范围

 | 

子网掩码

 |
| --- | --- | --- | --- |
| 甲级 | 1 至 126 | 1.0.0.0 到 126.255.255.254 | 255.0.0.0 |
| 乙类 | 128 至 191 | 128.0.0.0 到 191.255.255.254 | 255.255.0.0 |
| 丙类 | 192 至 223 | 192.0.0.0 到 223.255.255.254 | 255.255.255.0 |

在转换 IP 地址中的第一个十进制数后，我们的计算机只需查看前两位就能确定 IP 地址的类别。例如，在范围为 1 到 126 的 A 类中，二进制数字在 0000 0001 到 0111 1110 之间。前两位可能是 0 和 0 或 0 和 1。范围从 128 到 191 的 B 类具有从 1000 0000 到 1011 1111 的二进制数字范围。这意味着最高的第一位总是 1，第二位总是 0。范围从 192 到 223 的 C 类具有从 1100 0000 到 1101 1111 的二进制数字范围。前两位的位都是 1。参考下表，总结计算机如何通过检查 IP 地址的前两位来确定 IP 地址的类别(这里，X 被忽略，可以是任何十六进制字符):

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"></colgroup> 
| 

班级

 | 

二进制数字中的第一个数字

 |
| --- | --- |
| 甲级 | 00XXXXXX01XXXXXX |
| 乙类 | 10XXXXXX |
| 丙类 | 11XXXXXX |

通过对 IP 地址进行分类，我们还可以仅通过查看 IP 地址来确定子网掩码，因为每个类都有不同的子网掩码，如下所示:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

班级

 | 

范围

 | 

子网掩码

 |
| --- | --- | --- |
| 甲级地址 | 0 -126 | 255.0.0.0 |
| 乙类地址 | 128 至 191 | 255.255.0.0 |
| 丙类地址 | 192 至 223 | 255.255.255.0 |

通过知道子网掩码，我们可以很容易地知道网络 ID。假设我们有这三个 IP 地址:

*   `174.12.1.8`
*   `192.168.1.15`
*   `10.70.4.13`

现在，我们可以如下确定网络标识:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

IP 地址

 | 

班级

 | 

子网掩码

 | 

网络标识

 |
| --- | --- | --- | --- |
| 174.12.1.8 | 乙类 | 255.255.0.0 | 174.12.0.0 |
| 192.168.1.15 | 丙类 | 255.255.255.0 | 192.168.1.0 |
| 10.70.4.13 | 甲级 | 255.0.0.0 | 10.0.0.0 |

子网掩码还可以引用一个称为**无类域间路由** ( **CIDR** )的指示器，该指示器是根据位数定义的。例如，子网掩码`255.0.0.0`使用 8 位(值为`0`的位被视为未使用的位)，因此它被称为/8。同样，子网掩码 255.255.0.0 使用 16 位，可以引用为/16，子网掩码 255.255.255.0 使用 24 位，可以引用为/24。这些是我们之前的 IP 地址示例的 CIDR 符号:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

国际电脑互联网地址

 | 

子网掩码

 | 

cid 符号

 |
| --- | --- | --- |
| 174.12.1.8 | 255.255.0.0 | 174.12.1.8 /16 |
| 192.168.1.15 | 255.255.255.0 | 192.168.1.15 /24 |
| 10.70.4.13 | 255.0.0.0 | 10.70.4.13 /8 |

## 互联网协议版本 6–IPv6

IPv6 包含 128 位，是为了改进 IPv4 而推出的，IP v4 只有 32 位。IPv4 中有 32 位，可以寻址 4，294，967，296 个地址。一开始这个数字很高，但现在已经不够了，因为有很多设备需要一个 IP 地址。创建 IPv6 是为了解决这个问题，因为它可以寻址超过 340，000，000，000，000，000，000，000，000，000，000，或大约 *3.4028e+38* ，这已经足够了——至少目前是这样。

### 注

IPv5 已经被开发成由 64 位组成，但它从未被采用，因为人们认为如果使用互联网，它会很快耗尽 IP 地址。

IPv4 地址和 IPv6 地址的显著区别在于，IPv6 不是以十进制数字显示 IP 地址，而是以十六进制字符表示地址。我们只要看这个格式号，一眼就能确定是 IPv4 还是 IPv6。我们可以调用`ipconfig /all`命令来知道我们的 IPv6 地址，并在以太网适配器网络中看到它。我有`fe80::f14e:d5e6:aa0a:5855%3`，但你的肯定不一样。地址本身是`fe80::f14e:d5e6:aa0a:5855`，最后一个`%3`变量是一个区域索引，用来标识网络接口卡。第一个 IPv6 地址中的数字`fe80`表示为链路本地地址，这是一个在网络上自动分配的 IP 地址，因为它不是由 DHCP 自动配置的，或者尚未手动配置。

众所周知，IPv6 实际上是一组 128 位，为了简化符号，它将其位转换为十六进制字符。假设我们有一组形成 IPv6 的二进制数字，如下所示:

```
0010 0000 0000 0001 0000 0000 0000 0000
0000 0000 0000 0000 0000 0000 0000 0000
0000 0000 0100 1111 0000 1001 0111 0011
1111 0101 1111 1110 1111 1000 1011 0110
```

如果我们将其转换为 IPv6 地址格式，就更容易了，而不是记住所有这些数字。首先，我们将每个四位数组转换为十六进制字符，我们将得到这些十六进制字符:

```
2001000000000000004f0973f5fef8b6
```

其次，我们用冒号分隔每组四个字符，如下所示:

```
2001:0000:0000:0000:004f:0973:f5fe:f8b6
```

第三，我们可以抛出每个四位数集合中的前导零，如下所示:

```
2001:0:0:0:4f:973:f5fe:f8b6
```

第四，我们将连续的零组折叠成一个空组，如下所示:

```
2001::4f:973:f5fe:f8b6
```

现在我们更容易记住这个 IPv6 地址。

### 注

一个由两个冒号(`::`)表示的空组意味着根据需要插入尽可能多的零来将该地址组成 128 位。IPv6 地址不允许有多个空组，因为我们很难确定每个空组中有多少个零。

同样，对于 IPv4，它通过查看第一个数字(实际上是前两位)来对 IP 地址进行分类，IPv6 的类型也可以通过查看其**前缀**来识别。这就是我们如何写网络标识`2001:04fe`以 32 位前缀开头的所有地址:

```
2001:04fe:: /32
```

这意味着所有地址的前 32 位是 0010 0000 0000 0001 000 0100 1111 1110。然而，为了便于阅读这个地址，我们使用十六进制字符代替。

# 使用 TCP/IP 工具进行故障排除

以下一些命令可用于跟踪任何 TCP/IP 错误。这些命令可用于检查是否有任何路由器关闭或是否建立了任何连接。这将有助于我们决定正确的解决方案。

## ipconfig 命令

我们之前使用了 `ipconfig`命令来识别媒体访问控制地址和 IP 地址。除此之外，我们还可以使用这个命令来检查 TCP/IP 配置。我们也可以使用这个命令，如下面几节所述。

### 显示全部配置信息

为了完整地显示配置信息，我们可以在控制台上调用以下命令:

```
ipconfig /all

```

所有关于网络适配器的配置信息都将为我们显示，例如网络接口卡、无线卡和以太网适配器，就像我们在本章的*数据链路层*部分寻找 MAC 地址时已经尝试过的那样。

### 显示域名系统

以下命令将使用以下选项显示域名解析器缓存的内容:

```
ipconfig /displaydns

```

通过调用前面的命令，我们将获得关于本地系统中的域名系统的信息，如下所示:

```
Windows IP Configuration

 ipv4only.arpa
 ----------------------------------------
 Record Name . . . . . : ipv4only.arpa
 Record Type . . . . . : 1
 Time To Live  . . . . : 77871
 Data Length . . . . . : 4
 Section . . . . . . . : Answer
 A (Host) Record . . . : 192.0.0.170

 Record Name . . . . . : ipv4only.arpa
 Record Type . . . . . : 1
 Time To Live  . . . . : 77871
 Data Length . . . . . : 4
 Section . . . . . . . : Answer
 A (Host) Record . . . : 192.0.0.171

 ieonlinews.microsoft.com
 ----------------------------------------
 Record Name . . . . . : ieonlinews.microsoft.com
 Record Type . . . . . : 1
 Time To Live  . . . . : 307
 Data Length . . . . . : 4
 Section . . . . . . . : Answer
 A (Host) Record . . . : 131.253.34.240

```

显示域名系统输出中每个字段的含义如下:

*   **记录名称**:这是要与 IP 地址关联的 DNS 的名称。
*   **记录类型**:这是记录的类型，用数字表示。
*   **生存时间**:这是缓存过期时间，单位为秒。
*   **数据长度**:这是以字节为单位存储记录值文本的内存大小。
*   **段**:如果值为`Answer`，则表示回复实际查询，但是如果值为`Additional`，则表示包含查找实际答案所需的信息。
*   **A(主机)记录**:这个是实际值存放的地方。

### 刷新域名系统

以下命令用于删除解析的域名系统服务器项目，但不删除缓存中的项目。在命令提示符下键入以下命令:

```
ipconfig /flushdns

```

一旦它成功刷新了 DNS 解析器缓存，我们将在控制台中看到以下消息:

```
Successfully flushed the DNS Resolver Cache.

```

如果我们再次调用`ipconfig /displaydns`命令，解析的 DNS 服务器已经被移除，剩下的是缓存中的项目。

### 更新 IP 地址

有两个命令可以用来更新一个 IP 地址，它们是:

```
ipconfig /renew

```

前面的命令将从 DHCP 服务器更新 IPv4 的租用过程，而下面的命令将更新 IPv6 的租用过程:

```
ipconfig /renew6

```

### 释放 IP 地址

使用以下两个命令分别释放从 DHCP 服务器获取的 IPv4 和 IPv6 的租用过程:

```
ipconfig /release
ipconfig /release6

```

这些命令只影响 DHCP 分配的(自动分配的)IP 地址。

## ping 命令

`ping` 命令用于检查与其他计算机的连通性。它使用**互联网控制消息协议** ( **ICMP** )向目标计算机发送消息。我们可以使用 IP 地址和主机名 ping 目标。假设我们有一个主机名为`HOST1`的设备，要 ping 它自己，我们可以使用以下命令:

```
ping HOST1

```

然后，我们将在控制台窗口中获得以下输出:

```
Pinging HOST1 [fe80::f14e:d5e6:aa0a:5855%3] with 32 bytes of data:
Reply from fe80::f14e:d5e6:aa0a:5855%3: time<1ms
Reply from fe80::f14e:d5e6:aa0a:5855%3: time<1ms
Reply from fe80::f14e:d5e6:aa0a:5855%3: time<1ms
Reply from fe80::f14e:d5e6:aa0a:5855%3: time<1ms

Ping statistics for fe80::f14e:d5e6:aa0a:5855%3:
 Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
 Minimum = 0ms, Maximum = 0ms, Average = 0ms

```

如果我们获得了 IPv6 地址，并希望将其显示在 IPv4 地址中，我们可以使用`-4`选项强制使用 IPv4 地址，如以下代码所示:

```
ping HOST1 -4

```

然后，我们将获得如下输出:

```
Pinging HOST1 [10.1.6.165] with 32 bytes of data:
Reply from 10.1.6.165: bytes=32 time<1ms TTL=128
Reply from 10.1.6.165: bytes=32 time<1ms TTL=128
Reply from 10.1.6.165: bytes=32 time<1ms TTL=128
Reply from 10.1.6.165: bytes=32 time<1ms TTL=128

Ping statistics for 10.1.6.165:
 Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
 Minimum = 0ms, Maximum = 0ms, Average = 0ms

```

但是，如果我们显示的是 IPv4 地址，而我们需要进入 IPv6 地址呢？我们可以使用`-6`选项强制使用 IPv6 地址，如下所示:

```
ping HOST1 -6

```

从`ping`命令，有两点发生。首先，名为`HOST1`的计算机被解析为`10.1.6.165`的 IP 地址。如果主机名解析不起作用，我们将得到如下错误:

```
Ping request could not find host HOST1\. Please check the name and try again.

```

第二，该命令向`HOST1`发送四个数据包，接收四个数据包。该回复表示名为`HOST1`的计算机工作正常，能够响应命令请求。如果`HOST1`无法响应请求或被禁用，我们将看到如下输出:

```
Pinging HOST1 [10.1.6.165] with 32 bytes of data:
Request timed out.
Request timed out.
Request timed out.
Request timed out.
Ping statistics for 192.168.1.112:
 Packets: Sent = 4, Received = 0, Lost = 4 (100% loss),

```

发送`ping`命令时，我们可能会遇到一些错误信息，其中一些如下:

*   **目的主机不可达**:表示路由有问题。这可能是因为本地计算机或远程计算机中的默认网关配置错误。
*   **TTL 在传输中过期**:这表示 ping 过程通过的路由器数量大于 TTL(生存时间)值。每次 ping 通过路由器时，TTL 值都会递减。如果 ping 必须通过的路由器总数超过 TTL 值，将显示此错误消息。

我们可以在 ping 命令中使用的另一个选项是`–t`。有了这个选项，`ping`命令不再发送四个数据包，而是继续发送数据包，直到用户按下 *Ctrl* + *C* 停止发送。这通常在我们等待断开状态转为连接状态时使用。我们可以将命令发送到控制台，如下所示:

```
ping HOST1 -t

```

## tracert 命令

当我们有多台路由器时，我们可以使用`tracert`命令来跟踪数据包经过的路径。`tracert` 命令类似于`ping`命令，只是`tracert`有源设备和目的设备之间路由器的信息。这是我用来追踪从我的设备到[google.com](http://google.com)的通信轨迹的命令:

```
tracert google.com

```

我在控制台窗口中获得了以下输出:

```
Tracing route to google.com [173.194.126.32]
over a maximum of 30 hops:

 1     1 ms     1 ms     1 ms  254.1.168.192.in-addr.arpa [192.168.1.254]
 2    23 ms    26 ms     *     125.166.200.1
 3     *        *      331 ms  189.subnet125-160-11.speedy.telkom.net.id [125.1
 60.11.189]
 4   293 ms    76 ms    84 ms  73.171.94.61.in-addr.arpa [61.94.171.73]
 5   504 ms   612 ms   612 ms  61.94.117.229
 6   698 ms   714 ms   209 ms  42.193.240.180.in-addr.arpa [180.240.193.42]
 7     *        *        *     Request timed out.
 8     *        *        *     Request timed out.
 9     *      668 ms   512 ms  190.221.14.72.in-addr.arpa [72.14.221.190]
 10     *        *        *     Request timed out.
 11     *        *      582 ms  136.142.85.209.in-addr.arpa [209.85.142.136]
 12   184 ms   202 ms   202 ms  233.242.85.209.in-addr.arpa [209.85.242.233]
 13     *        *      563 ms  241.251.85.209.in-addr.arpa [209.85.251.241]
 14   273 ms    96 ms    83 ms  kul01s08-in-f0.1e100.net [173.194.126.32]

Trace complete.

```

可以看到有 14 行，每行代表一个**跳**(一种`ping`命令通过路由器的情况)。如果我们将一行除以一列，例如第四行，我们将得到下表:

<colgroup class="calibre16"><col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"> <col class="calibre17"></colgroup> 
| 

Hop #

 | 

RTT1

 | 

RTT2

 | 

RTT3

 | 

名称/IP 地址

 |
| --- | --- | --- | --- | --- |
| four | 293 毫秒 | 76 毫秒 | 84 毫秒 | 61.94.171.73 |

每行的解释如下:

*   **跳数**:这是第一列，只是路线沿途的跳数。
*   **RTT 栏目**:这是我们的包裹到达目的地返回电脑的**往返时间** ( **RTT** )。RRT 分为三列，因为 `tracecert`命令发送三个独立的信号包。这是为了显示路线的一致性，或缺乏一致性。
*   **域/IP 栏**:这是路由器的 IP 地址。如果域名可用，也将通知。

## 路径选择命令

`pathping`命令用于验证路由路径。它像`tracert`命令一样检查两台设备的路由，然后像`ping`命令一样检查每台路由器的连通性。 `pathping`命令向每台路由器发送 100 条请求命令，期望得到 100 条回复。对于每个没有被回复的请求，`pathping`命令将把它算作 1%的数据丢失。因此，例如，如果有十个请求没有回复，将会有 10%的数据丢失。数据丢失的百分比越小，我们的连接就越好。

我们将尝试借助以下命令将`pathping`命令发送到[google.com](http://google.com):

```
pathping google.com

```

通过这样做，我们将获得如下输出:

```
Tracing route to google.com [173.194.126.67]
over a maximum of 30 hops:
 0  HOST1 [10.1.7.101]
 1  10.1.7.1
 2  ns.csl-group.net [192.168.2.4]
 3  101.255.54.25
 4  115.124.80.209
 5  peer-Exch-D2-out.tachyon.net.id [115.124.80.73]
 6  ip-sdi.net.id [103.11.31.1]
 7  ip-31-253.sdi.net.id [103.11.31.253]
 8  209.85.243.158
 9  216.239.40.129
 10  209.85.242.243
 11  209.85.251.175
 12  kul06s05-in-f3.1e100.net [173.194.126.67]

Computing statistics for 300 seconds...
 Source to Here   This Node/Link
Hop  RTT    Lost/Sent = Pct  Lost/Sent = Pct  Address
 0                                           HOST1 [10.1.7.101]
 0/ 100 =  0%   |
 1   33ms     1/ 100 =  1%     1/ 100 =  1%  10.1.7.1
 0/ 100 =  0%   |
 2   24ms     1/ 100 =  1%     1/ 100 =  1%  ns.csl-group.net [192.168.2.4]
 0/ 100 =  0%   |
 3   19ms     1/ 100 =  1%     1/ 100 =  1%  101.255.54.25
 0/ 100 =  0%   |
 4   18ms     1/ 100 =  1%     1/ 100 =  1%  115.124.80.209
 0/ 100 =  0%   |
 5   33ms     1/ 100 =  1%     1/ 100 =  1%  peer-Exch-D2-out.tachyon.net.id [115.124.80.73]
 0/ 100 =  0%   |
 6   53ms     0/ 100 =  0%     0/ 100 =  0%  ip-sdi.net.id [103.11.31.1]
 0/ 100 =  0%   |
 7   38ms     2/ 100 =  2%     2/ 100 =  2%  ip-31-253.sdi.net.id [103.11.31.253]
 0/ 100 =  0%   |
 8   44ms     1/ 100 =  1%     1/ 100 =  1%  209.85.243.158
 0/ 100 =  0%   |
 9   59ms     0/ 100 =  0%     0/ 100 =  0%  216.239.40.129
 4/ 100 =  4%   |
 10  ---     100/ 100 =100%    96/ 100 = 96%  209.85.242.243
 0/ 100 =  0%   |
 11  ---     100/ 100 =100%    96/ 100 = 96%  209.85.251.175
 0/ 100 =  0%   |
 12   62ms     4/ 100 =  4%     0/ 100 =  0%  kul06s05-in-f3.1e100.net [173.194.126.67]

Trace complete.

```

在第 10行和第 11 行，我们获得了 100%的数据包丢失，因为发送到网络的数据包丢失了 100 个。然而，这是不可能的，因为数据没有到达目的路由器，因为 ICMP 被路由器阻止。使用此命令，我们可以确定在哪个特定路由器中会遇到大比例的数据丢失，尤其是在连接了许多路由器的大型网络中。

我们也可以使用`–q`选项改变发送到路由器的请求数量。我们只需要在选项后说明新的请求数量，如下所示:

```
pathping -q 10 google.com

```

这将向路由器发送十个请求，而不是 100 个请求，速度会更快。

## netstat 命令

`netstat`(代表**网络统计**)命令通过显示当前设备中 TCP/IP 连接的所有信息，来查看 TCP/IP 统计。它将显示网络中涉及的连接、端口和应用程序的信息。我们可以通过在控制台窗口中键入以下命令来使用该命令:

```
netstat

```

之后，我们将获得如下输出所示的内容:

```
Active Connections

 Proto  Local Address          Foreign Address        State
 TCP    127.0.0.1:50239        HOST1:50240            ESTABLISHED
 TCP    127.0.0.1:50240        HOST1:50239            ESTABLISHED
 TCP    127.0.0.1:50242        HOST1:50243            ESTABLISHED
 TCP    127.0.0.1:50243        HOST1:50242            ESTABLISHED
 TCP    127.0.0.1:60855        HOST1:60856            ESTABLISHED
 TCP    127.0.0.1:60856        HOST1:60855            ESTABLISHED
 TCP    127.0.0.1:60845        HOST1:60846            ESTABLISHED
 TCP    127.0.0.1:60846        HOST1:60845            ESTABLISHED
 TCP    192.168.1.4:50257      a72-246-188-35:http    ESTABLISHED
 TCP    192.168.1.4:50258      a72-246-188-35:http    ESTABLISHED
 TCP    192.168.1.4:50259      a72-246-188-35:http    ESTABLISHED
 TCP    192.168.1.4:50260      a104-78-107-69:http    ESTABLISHED
 TCP    192.168.1.4:50261      a72-246-188-35:http    TIME_WAIT
 TCP    192.168.1.4:50262      a72-246-188-35:http    ESTABLISHED
 TCP    192.168.1.4:50263      151:http               SYN_SENT
 TCP    [::1]:12372            HOST1:49567            ESTABLISHED
 TCP    [::1]:49567            HOST1:12372            ESTABLISHED

```

我们可以看到`netstat`命令的输出中有四列。每一栏的解释如下:

*   **Proto** :显示协议名称，是 TCP 还是 UDP。
*   **本地地址**:显示本地计算机的 IP 地址和使用的端口号。如果服务器正在监听所有接口，星号(`*`)将显示为主机名。如果端口尚未建立，端口号也将显示为星号。
*   **对外地址**:显示插座连接的远程计算机的 IP 地址和端口号。如果端口尚未建立，端口号将显示为星号(`*`)。
*   **状态**:表示一个 TCP 连接的状态。我们可能得到的状态如下:
    *   **SYN_SEND** :这表示主动开放系统。
    *   **SYN_RECEIVED** :表示服务器刚从客户端收到 SYN 。
    *   **已建立**:表示客户端收到服务器的 SYN，会话建立。
    *   **LISTEN** :表示服务器准备接受连接。
    *   **FIN_WAIT_1** :这表示主动关闭系统。
    *   **TIMED_WAIT** :表示主动关闭后客户端进入此状态。
    *   **CLOSE_WAIT** :表示被动关闭，表示服务器刚从客户端收到第一个 FIN。
    *   **FIN_WAIT_2** :这表示客户端刚刚收到服务器对其第一个 FIN 的确认。
    *   **LAST_ACK** :这表示服务器发送自己的 FIN 时处于这种状态。
    *   **CLOSED** :表示服务器收到客户端的 ACK，连接现在关闭。

关于这些状态的更多细节和信息，可以到[tools.ietf.org/html/rfc793](http://tools.ietf.org/html/rfc793)查阅[第三章](3.html#page "Chapter 3. Introducing the Boost C++ Libraries")、*功能规范*。

## 远程登录命令

`telnet`(代表**终端网络**)命令用于通过 TCP/IP 网络访问远程计算机。在窗口中，有两个远程登录功能，即远程登录服务器和远程登录客户端。前者用于配置 Windows，以便侦听传入的连接并允许其他人使用它。而后者用于通过远程登录与任何服务器连接。

默认情况下，由于存在安全风险，Windows 系统上不安装远程登录。禁用远程登录更安全，因为攻击者可以使用远程登录检查系统上的开放端口。然而，没有人能阻止我们在系统中安装它。我们可以通过执行以下步骤来做到这一点:

1.  按*窗口* + *R* 打开**运行**窗口，在文本框中输入`%SYSTEMROOT%\System32\OptionalFeatures.exe`，然后按**确定**按钮。此时将打开**窗口功能**窗口。
2.  Check **Telnet Client** and **Telnet Server** options, and then press the **OK** button to confirm the change. The checked option will look like the following screenshot:

    ![The telnet command](../images/00014.jpeg)

Telnet 现在应该已经安装在我们的计算机上了。打开命令提示符窗口，运行以下命令启动远程登录:

```
telnet

```

按下*进入*后，会出现如下输出，光标在最后闪烁:

```
Welcome to Microsoft Telnet Client
Escape Character is 'CTRL+]'
Microsoft Telnet>_

```

现在，远程登录准备接收我们的命令。为了测试它，我们可以在其中运行各种命令。在远程登录中可用的命令的完整列表可以在[windows.microsoft.com/en-us/windows/telnet-commands](http://windows.microsoft.com/en-us/windows/telnet-commands)找到。

# 总结

在这一章中，当我们谈到网络体系结构时，我们知道了每一层在 OSI 和 TCP/IP 模型中的主要作用。我们探索了互联网协议，并能够区分 IPv4 和 IPv6 之间的区别。我们还能够确定子网掩码并对 IP 地址进行分类。此外，我们能够使用各种 TCP/IP 工具来检测错误是否发生。

在下一章中，我们将讨论 Boost C++库，它将使我们在 C++编程中更有效率。现在，让我们准备好我们的编程工具，进入下一章。**