# 前言

欢迎来到 C++函数式编程的实践之旅！这本书讲的是一个老思想，那就是函数式编程，还有一种经典的编程语言，那就是 C++，最后凝聚力量。

函数式编程从 20 世纪 50 年代就出现了；然而，由于其数学基础，多年来主流软件开发对其兴趣有限。随着多核 CPU 和大数据的出现导致对并行化的需求，随着编程语言设计者对不变性和 lambdas 越来越感兴趣，函数式编程概念已经逐渐被引入到所有主要的编程语言中，包括 C#、Java、PHP、JavaScript、Python 和 Ruby。C++从未远离函数式编程，函数指针、函子和 STL 的算法等特性允许许多程序员利用某些构造。然而，从 C++ 11 开始，我们看到了 lambdas 的引入，以及更高阶的函数，如`all_of`、`any_of`和`none_of`。在 C++ 17 中，我们看到了更多的进步，引入了`map`(实现为`transform`)。此外，C++ 20 中的特性非常令人兴奋；例如，允许可组合、轻量级和延迟评估的转换的 ranges 库是对标准的一个很好的补充。

这就引出了你将从这本书中学到的东西。无论您是经验丰富的程序员还是 C++初学者，您都将了解函数式编程概念，如何在 C++中使用它们，以及它们为什么对管理和改进现有代码库有用。每个想法都将展示清晰的代码样本，并通过单元测试进行验证；我们强烈建议您带着这些代码样本，自己玩一玩。

已经作出特别努力，确保以明确的方式提出每一个想法，并遵循理解的流程；换句话说，我们一直在关注优化您的学习体验。为了做到这一点，我们决定夸大某些结构的使用。例如，示例代码使用了大量 lambdas，因为我们想展示如何使用它们。我们认为，学习函数式编程的最好方法是完全深入 lambdas 的世界和 lambdas 上的操作。我们期望读者将这种方法与生产方法分开；事实上，我建议您先自己试验这些概念，然后在生产代码的小部分上进行试验，然后才使用那些有希望充分发挥其潜力的概念。为了支持这个目标，我们已经记录了在函数上使用操作的多种方法，这样您将拥有足够的工具在各种环境中使用。

值得注意的是，我们经过深思熟虑后决定在本书的大部分内容中介绍 C++ 17 标准。我们不使用外部库(除了单元测试库)，我们坚持语言的标准特性和**标准模板库** ( **STL** )。重点是函数式编程概念以及如何使用极简方法实现它们。唯一的例外是这本书的最后一部分，它着眼于 C++和 STL 的未来。我们这样做是因为我们相信，对您来说，理解概念并准备好用最少的工具应用它们比提供大量的实现选项更重要。这省去了本书大部分内容的范围库、对函数式编程的 Boost 库支持，以及很可能是其他可以扩展或简化代码的有用库。我将把它留给读者自己试用，让我们知道它们是如何工作的。

# 这本书是给谁的

这本书是为那些已经知道 C++(包括语言语法、STL 容器和模板元素)并想在工具包中添加更多工具的程序员准备的。读这本书不需要了解函数式编程；我们小心翼翼地用清晰实用的方式解释每一个想法。

但是，您确实需要对来自函数式编程世界的工具集感到好奇。大量的实验将帮助你充分利用这本书，所以我鼓励你玩代码，让我们知道你的发现。

# 这本书涵盖了什么

[第一章](01.html)，*函数式编程入门*，为你介绍函数式编程的基本思想。

[第二章](02.html)、*理解纯函数*，教你函数编程的基本构造块，关注不变性的函数，以及如何用 C++编写它们。

[第三章](03.html)、*深入 Lambdas* ，重点介绍 Lambdas 以及如何用 C++编写。

[第四章](04.html)*功能组合的思想*，着眼于如何用更高阶的操作组合功能。

[第五章](05.html)、*部分应用和 Currying* ，教你如何在函数上使用两个基本操作——c++中的部分应用和 Currying。

[第 6 章](06.html)、*功能思考——从数据输入到数据输出*，向您介绍了另一种组织代码的方式，支持以功能为中心的设计。

[第 7 章](07.html)、*用功能操作*消除重复，是对**不重复自己** ( **DRY** )原理、代码重复的类型和代码的相似性，以及如何使用组合、部分应用、curry 等功能操作编写更多 DRY 代码的概述。

[第 8 章](08.html)、*使用类*提高内聚性，演示了函数如何进化成类，以及类如何变成函数。

[第 9 章](09.html)、*功能编程的测试驱动开发*，关注如何将**测试驱动开发** ( **TDD** )用于功能编程，以及不变性和纯函数如何简化测试。

[第 10 章](10.html)、*性能优化*深入探讨了如何优化以功能为中心的设计性能的具体方法，包括记忆化、尾部递归优化和并行执行。

[第 11 章](11.html)、*基于属性的测试*研究了函数式编程如何支持编写自动化测试的新范例，该范例通过数据生成增强基于示例的测试。

[第 12 章](12.html)、*重构到纯函数并通过纯函数*，解释了如何将任何现有代码重构到纯函数，然后以最小的风险返回到类中。它还关注经典设计模式和一些功能设计模式。

[第 13 章](13.html)、*不变性和架构-事件源*，解释了不变性可以在数据存储层面移动，看了如何使用事件源，并讨论了它的优缺点。

[第 14 章](14.html)、*使用范围库*的懒惰评估，深入到令人敬畏的范围库，并演示如何在 C++ 17 和 C++ 20 中使用它。

[第 15 章](15.html)、 *STL 支持和建议*，关注 C++ 17 标准中的 STL 功能特性，以及 C++ 20 中一些有趣的补充。

[第 16 章](16.html)、*标准语言支持和建议*，以函数式编程的基本构造块和在 C++ 17 标准中使用它们的各种选项的概述结束本书。

# 充分利用这本书

这本书假定对 C++语法和基本的 STL 容器有很好的了解。然而，它没有假设任何函数编程、函数构造、范畴理论或数学的知识。我们竭尽全力确保每个概念都得到清晰的解释，并且是从实用的、以程序员为中心的角度出发。

我们强烈建议您在阅读完这些章节之后再去玩这些代码，或者在完成一章之后尝试从示例中复制这些代码。更好的是，选择一个编码卡塔(例如，来自[http://codingdojo.org/kata/](http://codingdojo.org/kata/))问题，并尝试使用本书中的技巧来解决它。把阅读和玩弄代码结合起来，你会学到比单纯地阅读理论本身更多的东西。

这本书的大部分内容要求你对代码结构进行不同的思考，有时，这将与你习惯的相反。然而，我们将函数式编程视为您工具包中的另一个工具；它与您已经知道的并不矛盾，相反，它只是为您提供了额外的工具来与您的生产代码一起使用。何时以及如何使用它们是你的决定。

要运行书中的代码示例，您将需要`g++`和`make`命令。或者，您可以使用任何支持 C++ 17 的编译器运行示例，但是您需要手动运行每个文件。所有的代码示例都是用`make`或`make [specific example]`编译并自动运行的，并在控制台上提供了输出，下面还有一些警告。

来自[第 10 章](10.html)、*性能优化*的内存优化样本，需要与`make allMemoryLogs`或特定目标一起运行，每次目标运行后需要按下键盘，并将在`out/`文件夹中创建日志文件，显示为进程分配的内存的演变。这只会在 Linux 系统上起作用。

反应式编程示例来自[第 10 章](10.html)、*性能优化*，需要用户输入。只要输入数字，程序就会以反应的方式计算它们是否是质数。即使在计算时，程序也应该接收输入。来自[第 16 章](16.html)、*标准语言支持与建议*的代码样本，需要支持 C++20 的编译器；此时，使用`g++-8`。您需要单独安装`g++-8`。

# 下载示例代码文件

你可以从你在[www.packt.com](http://www.packt.com)的账户下载这本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[www.packt.com/support](http://www.packt.com/support)并注册将文件直接通过电子邮件发送给您。

您可以按照以下步骤下载代码文件:

1.  登录或注册[www.packt.com](http://www.packt.com)。
2.  选择“支持”选项卡。
3.  点击代码下载和勘误表。
4.  在搜索框中输入图书的名称，并按照屏幕指示进行操作。

下载文件后，请确保使用最新版本的解压缩文件夹:

*   视窗系统的 WinRAR/7-Zip
*   zipeg/izp/un ARX for MAC
*   适用于 Linux 的 7-Zip/PeaZip

这本书的代码包也托管在 GitHub 上，网址为[https://GitHub . com/packt publishing/hand-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)。如果代码有更新，它将在现有的 GitHub 存储库中更新。

我们还有来自丰富的图书和视频目录的其他代码包，可在**[【https://github.com/PacktPublishing/】](https://github.com/PacktPublishing/)**获得。看看他们！

# 行动中的代码

请访问以下链接查看正在执行的代码:

[http://bit.ly/2ZPw0KH](http://bit.ly/2ZPw0KH)

# 使用的约定

本书通篇使用了许多文本约定。

`CodeInText`:表示文本中的码字、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟网址、用户输入和推特句柄。这里有一个例子:“在 STL 中，它是用`find_if`函数实现的。让我们看到它在行动。”

代码块设置如下:

```
class Number{
    public:
        static int zero(){ return 0; }
        static int increment(const int value){ return value + 1; }
}
```

当我们希望将您的注意力吸引到代码块的特定部分时，相关的行或项目以粗体显示:

```
First call: 1,367 ns < 16,281 ns
Second call: 58,045 ns < 890,056 ns Third call: 16,167 ns > 939 ns Fourth call: 1,334 ns > 798 ns
```

Warnings or important notes appear like this. Tips and tricks appear like this.

# 取得联系

我们随时欢迎读者的反馈。

**一般反馈**:如果你对这本书的任何方面有疑问，在你的信息主题中提到书名，发邮件给我们`customercare@packtpub.com`。

**勘误表**:虽然我们已经尽了最大的努力来保证内容的准确性，但是错误还是会发生。如果你在这本书里发现了一个错误，如果你能向我们报告，我们将不胜感激。请访问[www.packt.com/submit-errata](http://www.packt.com/submit-errata)，选择您的图书，点击勘误表提交链接，并输入详细信息。

**盗版**:如果您在互联网上遇到任何形式的我们作品的非法拷贝，如果您能提供我们的位置地址或网站名称，我们将不胜感激。请通过`copyright@packt.com`联系我们，并提供材料链接。

**如果你有兴趣成为一名作者**:如果有一个你有专长的话题，你有兴趣写或者投稿一本书，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

# 复习

请留下评论。一旦你阅读并使用了这本书，为什么不在你购买它的网站上留下评论呢？然后，潜在的读者可以看到并使用您不带偏见的意见来做出购买决定，我们在 Packt 可以了解您对我们产品的看法，我们的作者可以看到您对他们的书的反馈。谢谢大家！

更多关于 Packt 的信息，请访问[packt.com](http://www.packt.com/)。