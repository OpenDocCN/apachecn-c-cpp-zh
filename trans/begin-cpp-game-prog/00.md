# 序言

这本书是关于提供一个有趣的游戏编程世界介绍，C++，和 OpenGL 供电 SFML 使用五个有趣的，完全可玩的游戏，增加难度和先进的特点。这些游戏是一个上瘾的，疯狂的双键敲击游戏，一个乒乓游戏，一个多级僵尸生存射击游戏，一个分屏多人拼图平台，和一个射击游戏。

通过这一改进和扩展的第二版，我们将从编程的基本知识开始，例如变量、循环和条件，当您通过关键的 C++主题时，每一个游戏都会变得更加熟练，如 Po.T0.面向对象编程 To1 T1（MultT2OOP ToeT3），C++指针，以及对**标准模板库**（**STL**的介绍。在构建这些游戏的同时，您还将学习令人兴奋的游戏编程概念，如粒子效果、定向声音（空间化）、OpenGL 可编程着色器、如何生成数千个对象等。

# 这本书是给谁的

这本书对你来说是完美的，如果你有任何一个 C++编程知识，或者你需要一个初级水平的进修课程，如果你想学习游戏或者仅仅用游戏作为一种吸引学习 C++的方法，如果你有一天想要发布一个游戏的愿望，也许是在 Steam 上，或者，如果你只是想玩得开心，用你的作品给朋友留下深刻印象。

# 这本书涵盖的内容

【参考译文】第 1 章，T3，T4，C++，SFML，VisualStudio，开始第一个游戏 Ty5T5，代表了相当大的第一章，但我们将学习我们所需要的一切，以使我们的第一个游戏的第一部分运行和运行。以下是我们要做的：了解我们将要建立的游戏，发现 C++，了解微软 Visual C++，探索 SFML 及其与 C++的关系，建立开发环境，计划和准备第一个游戏项目，木材！！！在书中写第一个 C++代码，制作一个可绘制背景的可运行游戏。

【参考译文】T1，T2，T3，2，T4，5，5，变量，操作符和决策-动画精灵 StutyT7.，在屏幕上覆盖了更多的图形，为了实现这一点，我们需要学习 C++的一些基础知识。我们将学习如何使用变量来记忆和操纵值，我们还将开始在游戏中添加更多图形。随着本章的深入，我们将看到如何操纵这些值来设置图形动画。这些值称为变量。

【参考文献】第 3 章，T2，T3，C + +字符串和 SFML 时间-播放器输入和胡德 Ont5，继续木材！！！游戏我们将用本章的一半时间学习如何操作文本并在屏幕上显示，另一半时间学习计时以及视觉时间条如何通知玩家并在游戏中产生紧迫感。我们将包括以下几点：暂停和重新启动游戏，C++字符串，SFML 文本和 SFML 字体类，添加一个 HUD 到木材！！！并为木材添加时间条！！！。

【参考文献】第 4 章，第 3 章，第 3 章，第四章，循环，数组，开关，枚举，和函数-实现游戏力学，T5，也许比书中的其他章节有更多的 C++信息。它充满了将极大地提高我们理解力的基本概念。它还将开始揭示一些我们略过的模糊领域，比如函数和游戏循环。一旦我们探索了一个完整的 C++语言必需品列表，我们将使用我们所知道的一切来让主要游戏机制树干移动。到本章结束时，我们将为最后阶段和木材完工做好准备！！！。这就是我们将在本章中探讨的内容：循环、数组、使用开关进行决策、枚举、开始使用函数以及创建和移动树分支。

[*第 5 章*](05.html#_idTextAnchor138)*碰撞、声音和结束条件——使游戏可玩*，构成第一个项目的最后阶段。本章结束时，您将完成第一个完整的游戏。一旦你有了木材！！！启动和运行时，请务必阅读本章的最后一节，因为它将提出使游戏更好的方法。在本章中，我们将介绍以下主题：添加其余精灵、处理玩家输入、设置飞行日志动画、处理死亡、添加音效、添加功能和改进木材！！！。

[*第 6 章*](06.html#_idTextAnchor154)*面向对象编程——启动乒乓球游戏*包含了相当多的理论，但该理论将为我们提供知识，让我们开始使用 OOP 产生强大的效果。此外，我们不会浪费任何时间将该理论用于编写下一个项目，即乒乓球游戏。我们将在幕后了解如何通过编码一个类来创建用作对象的新类型。我们将首先看一个简化的乒乓球场景来学习一些基本的类知识，然后我们将重新开始，并使用我们所学的原理编写一个真实的乒乓球游戏。

[*第 7 章*](07.html#_idTextAnchor175)*动态碰撞检测与物理——完成乒乓球游戏*解释了如何编写我们的第二节课。我们将看到，尽管球显然与球拍有很大不同，但我们将使用完全相同的技术将球的外观和功能封装在`Ball`类中，就像我们对球拍和`Bat`类所做的那样。然后，我们将通过编码一些动态碰撞检测和记分，为乒乓球游戏添加最后的润色。这听起来可能很复杂，但是，正如我们所预期的，SFML 将使事情变得比其他方式简单得多。

[*第 8 章*](08.html#_idTextAnchor183)*，SFML 视图–启动僵尸射击游戏*，解释了该项目如何更多地使用 OOP，并产生强大的效果。我们还将探索 SFML`View`类。这个多才多艺的类将使我们能够轻松地将游戏划分为不同层面，以适应游戏的不同方面。在僵尸射手项目中，我们将有一个用于 HUD 的层和一个用于主游戏的层。这将是必要的，因为当玩家每次清除僵尸时，游戏世界都会扩大，最终，游戏世界将比屏幕更大，需要滚动。使用 View 类将防止 HUD 中的文本与背景一起滚动。在下一个项目中，我们将更进一步，创建一个协作的分屏游戏，SFML 视图类将完成大部分的艰苦工作。这就是我们在本章中要做的：规划僵尸竞技场游戏，编写`Player`类代码，了解 SFML 视图类，构建僵尸竞技场游戏引擎，让玩家类发挥作用。

【参考文献】第 9 章，第 4 章，第 5 章，第 6 章，C++参考文献，SpRITE 表，以及顶点数组 AUT7，探索 C++引用，它允许我们研究变量或对象，而这些变量和对象在范围之外。此外，引用将帮助我们避免在函数之间传递大型对象，这是一个缓慢的过程。这是一个缓慢的过程，因为每次执行此操作时，都必须创建变量或对象的副本。有了这些关于引用的新知识，我们将看一看 SFML`VertexArray`类，它允许我们建立一个大图像，可以使用单个图像文件中的多个部分快速有效地绘制到屏幕上。到本章结束时，我们将拥有一个可伸缩、随机、滚动的背景，使用引用和`VertexArray`对象。

【参考文献】第 10 章第 2 章：T3、3、4、指针、标准模板库和纹理管理（T5），首先介绍了指针的基本 C++主题。指针是保存内存地址的变量。通常，指针将保存另一个变量的内存地址。这听起来有点像一个参考，但我们将看到它们是如何更强大，我们将使用一个指针来处理不断扩大的僵尸群。我们还将了解 STL，它是一个类集合，允许我们快速轻松地实现常见的数据管理技术。一旦我们了解了 STL 的基本知识，我们将能够使用新获得的知识来管理游戏中的所有纹理，因为如果我们有 1000 个僵尸，我们真的不想为每个僵尸都将僵尸图形的副本加载到 GPU 中。我们还将深入研究 OOP 并使用静态函数，这是一个类的函数，可以在没有类实例的情况下调用。同时，我们将看到如何设计一个类以确保只有一个实例可以存在。当我们需要保证代码的不同部分将使用相同的数据时，这非常理想。

[*第 11 章*](11.html#_idTextAnchor249)*碰撞检测、拾音器和子弹*解释了到目前为止我们是如何实现游戏的主要视觉方面的。我们有一个可控的角色在竞技场里到处跑，竞技场上到处都是追逐他的僵尸。问题是它们之间没有互动。僵尸可以在玩家身上奇迹般地穿行而不留下划痕。我们需要检测僵尸和玩家之间的冲突。如果僵尸能够伤害并最终杀死玩家，我们给玩家一些子弹来换取他的枪是公平的。然后我们需要确保子弹能够击中并杀死僵尸。同时，如果我们正在为子弹、僵尸和玩家编写碰撞检测代码，那么也应该为生命和弹药拾取添加一个类。

[*第 12 章*](12.html#_idTextAnchor272)*分层视图和实现 HUD*是我们将看到 SFML 视图真正价值的一章。我们将添加大量 SFML`Text`对象并对其进行操作，就像我们之前在木材项目和 Pong 项目中所做的那样。新的是，我们将使用第二个视图实例绘制 HUD。这样，无论背景、玩家、僵尸和其他游戏对象在做什么，HUD 都将整齐地位于主要游戏动作的顶部。

【参考译文】第 13 章 A2 T2，To.T4，声音效果，文件 I/O，以及完成游戏 Ty5，演示了如何使用 C++标准库轻松地操作硬盘上存储的文件，我们还将添加声音效果。当然，我们知道如何添加声音效果，但我们将讨论在代码中调用 play 函数的确切位置。我们还将把一些松散的结束，使游戏完整。在本章中，我们将执行以下操作：使用文件输入和文件输出保存和加载 hi 乐谱，添加声音效果以允许播放器升级，并创建永无止境的多个波。

[*第 14 章*](14.html#_idTextAnchor292)*抽象和代码管理——更好地利用 OOP*，重点是启动 Thomas Was Lone 项目，特别是探索如何构建代码以更好地利用 OOP。以下是本章将涉及的主题的详细信息：介绍了最终项目 Thomas Was Late，包括游戏性功能和项目资产，并详细讨论了与以前的项目相比，我们将如何改进代码结构，代码 Thomas Was Late game engine，并实现分屏功能。

[*第 15 章*](15.html#_idTextAnchor306)*高级 OOP–继承和多态性*通过查看稍微高级一些的继承和多态性概念，进一步扩展了我们对 OOP 的了解。然后，我们将能够使用这一新知识来实现我们游戏中的明星角色，托马斯和鲍勃。这是我们将在本章中介绍的内容：学习如何使用继承来扩展和修改类，使用多态性将类的对象视为多种类型的类，学习抽象类以及如何设计从不实例化的类，构建抽象`PlayableCharacter`类，将继承与`Thomas`和`Bob`类一起使用，并将 Thomas 和 Bob 添加到游戏项目中。

[*第 16 章*](16.html#_idTextAnchor327)*构建可玩关卡和碰撞检测*可能是本项目最令人满意的章节之一。这样做的原因是，到比赛结束时，我们将有一个可玩的游戏。虽然仍有一些功能需要实现（声音、粒子效果、HUD 和着色器效果），但 Bob 和 Thomas 将能够奔跑、跳跃和探索世界。此外，通过在文本文件中创建平台和障碍物，您将能够创建任何大小或复杂度的自己的关卡设计。我们将通过以下主题来实现这一切：探索如何在文本文件中设计关卡，构建一个`LevelManager`类，该类将从文本文件中加载关卡，将其转换为游戏可以使用的数据，并跟踪关卡细节，如繁殖位置、当前关卡和允许的时间限制，更新游戏引擎以使用`LevelManager`，并编写一个多态函数来处理 Bob 和 Thomas 的碰撞检测。

[*第 17 章*](17.html#_idTextAnchor340)*声音空间化和 HUD*添加了所有音效和 HUD。我们在之前的两个项目中都做过，但是这次我们会做一些不同的事情。我们将探讨声音空间化的概念，以及 SFML 如何使这一复杂的概念变得简单易懂。此外，我们将构建一个 HUD 类来封装将信息绘制到屏幕上的代码。我们将按照以下顺序完成任务：什么是空间化，SFML 如何处理空间化，构建`SoundManager`类，部署发射器，使用`SoundManager`类，构建然后使用 HUD 类。

[*第 18 章*](18.html#_idTextAnchor356)*粒子系统和着色器*检查了什么是粒子系统，然后将其编码到我们的游戏中。我们将触及 OpenGL 着色器主题的表面，并了解如何使用另一种语言**OpenGL 着色语言**（**GLSL**）编写代码，该语言可以直接在图形卡上运行，从而产生平滑的图形效果，否则可能无法实现。像往常一样，我们也将使用我们的新技能和知识来加强当前项目。

[*第 19 章*](19.html#_idTextAnchor372)*游戏编程设计模式——启动太空入侵者+*游戏，介绍最终项目。正如你现在所期待的，这个项目将在学习新的 C++技术方面迈出重要的一步。接下来的四章将讨论一些主题，包括智能指针、C++断言、使用 GAMEPAD 控制器、使用 VisualStudio 调试、将基类指针转换成特定派生类的指针、调试以及首先查看设计模式。作者推测，如果你打算在 C++中进行深度、大规模的游戏，那么设计模式将成为你未来几个月和几年学习议程的一个重要部分。为了介绍这个重要的主题，我选择了一个相对简单但有趣的游戏作为例子。让我们进一步了解一下太空入侵者++游戏，然后我们可以继续讨论设计模式以及为什么需要它们。在这一重要的章节中，我们将涵盖以下主题：了解太空入侵者++以及为什么选择它作为最终项目，了解什么是设计模式以及它们对游戏开发者的重要性，研究太空入侵者++项目中的设计模式，这些设计模式将在接下来的四章中使用，开始太空入侵者++项目，编写大量的类来充实游戏。

[*第 20 章*](20.html#_idTextAnchor414)*游戏对象和组件*涵盖了我们在上一章开始讨论的与实体组件模式相关的所有编码。这意味着我们将对所有其他组件将从中派生的基本组件类进行编码。我们还将充分利用我们对智能指针的新知识，这样我们就不必关注我们为这些组件分配的内存。我们还将在本章中对`GameObject`类进行编码。以下是本章各节的列表：准备对组件进行编码、对组件基类进行编码、对碰撞器组件进行编码、对图形组件进行编码、对更新组件进行编码以及对`GameObject`类进行编码。

[*第 21 章*](21.html#_idTextAnchor432)*文件 I/O 和游戏对象工厂*解释了`GameObject`如何进入游戏中使用的`m_GameObjects`向量。我们将看到如何在文本文件中描述单个对象和整个级别。我们将编写代码来解释文本，然后将值加载到一个类中，该类将成为游戏对象的蓝图。我们将编写一个名为`LevelManager`的类来监督整个过程，从最初请求加载`InputHandler`通过`ScreenManager`发送的关卡开始，一直到工厂模式类，工厂模式类从组件组装游戏对象，并将其交付给`m_GameObjects`向量中整齐包装的`LevelManager`类。

[*第 22 章*](22.html#_idTextAnchor445)*使用游戏对象并构建游戏*，构成空间入侵者++项目的最后阶段。我们将学习如何使用 SFML 从游戏板接收输入来完成所有的艰苦工作，我们还将编写一个类来处理入侵者和`GameScreen`类之间的通信，以及玩家和`GameScreen`类之间的通信。该类将允许玩家和入侵者产生子弹，但完全相同的技术可用于您自己游戏不同部分之间需要的任何类型的通信，因此了解这一点很有用。游戏的最后一部分（和往常一样）将是碰撞检测和游戏本身的逻辑。一旦 Space Invaders++启动并运行，我们将学习如何使用 Visual Studio 调试器，当您设计自己的逻辑时，调试器将非常有用，因为它允许您一次一行地遍历代码，并查看变量的值。它也是一个有用的工具，用于研究我们在本项目过程中组装的模式的执行流程。

[*第 23 章*](23.html#_idTextAnchor457)*在您离开之前。。。*结束了我们的旅程。当你第一次打开一本书的大门挡时，它的后页看起来好像离你很远。但我希望不是太难吧？关键是你现在在这里，希望你能很好地了解如何用 C++来构建游戏。你可能会惊讶地发现，即使在这几百页之后，我们也只能把脚趾浸到 C++中。即使是我们已经讨论过的话题，也可以更深入地讨论，还有很多，一些相当重要的话题，我们甚至没有提到。考虑到这一点，让我们来看看下一步会是什么。

# 充分利用这本书

需要满足以下要求：

*   Windows 7 Service Pack 1、Windows 8 或 Windows 10
*   1.6 GHz 或更快的处理器
*   1 GB 内存（用于 x86）或 2 GB 内存（用于 x64）
*   15 GB 的可用硬盘空间
*   5400 RPM 硬盘驱动器
*   支持 DirectX 9 的视频卡，以 1024 x 768 或更高的显示分辨率运行

本书中使用的所有软件都是免费的。本书将逐步介绍如何获取和安装软件。本书始终使用 VisualStudioforWindows，但是有经验的 Linux 和 Mac 用户在使用他们喜欢的编程环境运行代码和遵循说明方面可能不会有问题。

## 下载示例代码文件

您可以从您的账户[www.packt.com](http://www.packt.com)下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packtpub.com/support](http://www.packtpub.com/support)并注册，将文件通过电子邮件直接发送给您。

您可以通过以下步骤下载代码文件：

1.  在“T0”登录或注册 http://www.packt.com T1-T1
2.  选择**支持**选项卡。
3.  点击**代码下载**。
4.  在**搜索**框中输入图书名称，并按照屏幕上的说明进行操作。

下载文件后，请确保使用以下最新版本解压或解压缩文件夹：

*   WinRAR/7-Zip for Windows
*   适用于 Mac 的 Zipeg/iZip/UnRarX
*   适用于 Linux 的 7-Zip/PeaZip

该书的代码包也托管在 GitHub 上的[https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition](https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition) 。如果代码有更新，它将在现有 GitHub 存储库中更新。

我们的丰富书籍和视频目录中还有其他代码包，请访问[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/) 。看看他们！

## 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图像。您可以在这里下载：[https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf](https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf) 。

## 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的码字、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。例如：“我的主要项目目录是`D:\VS Projects\Timber`

代码块设置如下：

```cpp
int main()
{
    return 0;
}
```

当我们希望提请您注意代码块的特定部分时，相关行或项目以粗体显示：

```cpp
int main()
{
    return 0;
}
```

**粗体**：表示一个新术语、一个重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词出现在文本中，如下所示。下面是一个例子：“点击**新建项目**按钮。”

重要提示

警告或重要提示如下所示。

提示

提示和技巧如下所示。

# 联系

我们欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中注明书名，并发送电子邮件至[customercare@packtpub.com](mailto:customercare@packtpub.com)。

**勘误表**：尽管我们已尽一切努力确保内容的准确性，但还是会出现错误。如果您在本书中发现错误，如果您能向我们报告，我们将不胜感激。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)，选择您的书籍，单击 errata 提交表单链接，然后输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何形式的非法复制品，请您提供我们的位置地址或网站名称，我们将不胜感激。请致电[与我们联系 copyright@packt.com](mailto:copyright@packt.com)带有指向该材料的链接。

**如果您有兴趣成为一名作家**：如果您对某个主题有专业知识，并且您有兴趣撰写或贡献一本书，请访问[authors.packtpub.com](http://authors.packtpub.com)。

## 审查

请留下评论。一旦你阅读并使用了这本书，为什么不在你购买它的网站上留下评论呢？然后，潜在读者可以看到并使用您的无偏见意见做出购买决定，我们 Packt 可以了解您对我们产品的看法，我们的作者可以看到您对他们书籍的反馈。非常感谢。

有关 Packt 的更多信息，请访问[Packt.com](http://packt.com)。