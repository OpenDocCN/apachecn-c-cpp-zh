# 零、前言

长期以来，嵌入式系统的开发要么需要纯 C 语言，要么需要汇编语言。 这其中有很多很好的理由。 硬件没有足够的资源来运行用高级编程语言(如 C++、Java 或 Python)编写的应用，但更重要的是，没有真正需要用这些语言编写软件。 有限的硬件资源限制了软件的复杂性，嵌入式应用的功能仍然相对简单，而 C 语言的能力足以实现它。

随着硬件开发的进步，如今越来越多的嵌入式系统采用价格低廉但功能强大的片上系统(System-on-Chip，System-on-Chip)，能够运行 Linux 等通用多任务操作系统。

不断增长的硬件能力要求更复杂的软件，而 C++ 越来越多地成为新的嵌入式系统的首选语言。 有了它的*，您就不必为不使用*方法付费了。它允许开发人员创建使用计算和内存资源的应用，就像用 C 编写的应用一样，但是它为开发人员提供了更多的工具来处理复杂性和更安全的资源管理，例如面向对象编程和 RAII 习惯用法。

在 C 方面有丰富经验的经验丰富的嵌入式开发人员通常倾向于以类似的习惯方式用 C++ 编写代码，将这种语言视为 C 的面向对象扩展，C 是具有类的*C。 然而，现代 C++ 有自己的最佳实践和概念，如果使用得当，可以帮助开发人员避免常见的陷阱，并允许他们在几行代码中做很多事情。*

另一方面，具有 C++ 经验进入嵌入式系统世界的开发人员应该意识到特定硬件平台和应用域的要求、限制和功能，并相应地设计他们的 C++ 代码。

这本书的目标是弥合这一差距，并演示如何将现代 C++ 的特性和最佳实践应用于嵌入式系统的上下文中。

# 这本书是写给谁的？

本书面向希望用 C++ 构建高效嵌入式程序的开发人员和电子硬件、软件和片上系统工程师。

嵌入式系统的世界是广阔的。 这本书试图涵盖其中的一种类型，运行 Linux 操作系统(如 Raspberry PI 或 BeagleBoard)的 SoC，简要介绍低级微控制器(如 Arduino)。

要求熟悉 C++，但不需要深入的 C++ 知识或嵌入式系统经验。

# 这本书涵盖了哪些内容

[第 1 章](01.html)，*嵌入式系统基础*定义了什么是嵌入式系统，它们与其他系统有何不同，为什么需要特定的编程技术，以及为什么 C++ 很好，在很多情况下是嵌入式开发的最佳选择。 它概述了嵌入式开发人员在日常工作中遇到的限制和挑战：有限的系统资源和 CPU 性能、处理硬件错误以及远程调试。

[第 2 章](02.html)，*设置环境*解释了嵌入式系统开发环境与 Web 或桌面应用开发的区别，并介绍了构建和目标系统、交叉编译和交叉工具包、串行控制台和远程外壳等概念。 它提供了为运行 Windows、MacOS 或 Linux 的最常见桌面配置设置虚拟化构建和目标主机的实用步骤。

[第 3 章](03.html)*使用不同的体系结构*解释了如何在 C++ 代码中考虑目标系统的 CPU 体系结构和内存配置方面的重要差异。

[第 4 章](04.html)，*处理中断*，涵盖了中断和中断服务例程的低级概念。 在现代操作系统中，即使是开发人员或设备驱动程序也必须使用操作系统提供的更高级别的 API。 这就是为什么我们使用 8051 单片机来探索中断技术的原因。

[第 5 章](05.html)，*调试、日志记录和分析*，介绍了特定于基于 Linux 的嵌入式系统的调试技术，例如直接在目标板上运行 gdb、设置 gdbserver 以进行远程调试，以及日志记录对调试和故障根本原因分析的重要性。

[第 6 章](06.html)，*内存管理*提供了几个内存分配的秘诀和最佳实践，对嵌入式系统的开发人员很有帮助。 我们讨论为什么在嵌入式应用中避免动态内存分配，以及可以考虑哪些替代方案来实现快速、确定性的内存分配。

[第 7 章](07.html)，*多线程和同步*解释了如何使用 C++ 标准库提供的函数和类来实现高效的多线程应用，这些应用可以利用现代多核 CPU 的所有功能。

[第 8 章](08.html)，*通信和序列化*，涵盖了进程间和系统间通信的概念、挑战和最佳实践，例如套接字、管道、共享内存和使用 FlatBuffers 库的内存高效序列化。 使用定义良好的异步协议将应用解耦为相互通信的独立组件，是在保持软件系统快速和容错的同时扩展软件系统的事实上的标准方式。

[第 9 章](09.html)，*外部设备*解释了如何在 C++ 程序中使用各种外部设备。 虽然大多数设备通信 API 不依赖于特定的编程语言，但我们将学习如何使用 C++ 的强大功能来编写便于开发人员并帮助防止常见资源泄漏错误的包装器。

[第 10 章](10.html)，*降低功耗*探讨了编写高能效应用和利用操作系统电源管理功能的最佳实践。 它为基于 Linux 的嵌入式系统提供了几个实用的配方，但是相同的概念可以扩展到任何操作系统和任何平台。

[第 11 章](11.html)，*时间点和间隔*涵盖了与时间操作相关的各种主题，从测量间隔到添加延迟。 我们将了解标准 C++ Chrono 库提供的 API，以及如何有效地使用它来构建可移植的嵌入式应用。

[第 12 章](12.html)，*错误处理和容错*探讨了用 C++ 编写的嵌入式应用错误处理的可能实现和最佳实践。 它解释了如何有效地使用 C++ 异常，并将其与传统错误代码和复杂返回类型等备选方法进行了比较。 它涉及到基本的容错机制，如看门狗计时器和心跳。

[第 13 章](13.html)，*实时系统指南*，涵盖了实时系统的细节。 它简要描述了实时系统是如何定义的，以及存在哪些类型的实时系统。 它包含关于如何使应用的行为更具确定性的实用食谱，这是实时系统的关键要求。

[第 14 章](14.html)，*《安全关键系统指南》*解释了什么是安全关键系统，以及它们与其他嵌入式系统的不同之处。 它涵盖了在安全关键型系统上工作时所需的开发方法和工具，从遵循 MISRA、AUTOSAR 或 JSF 等形式化编码指南到使用静态代码分析或正式软件验证工具。

[第 15 章](15.html)，*微控制器编程*概述了编写、编译和调试微控制器 C++ 代码的基本概念。 我们将以广泛使用的 Arduino 板为例学习如何设置开发环境。

# 为了最大限度地利用这本书

嵌入式系统的开发意味着您的应用将与某种特定的硬件交互-特定的 SoC 平台、特定的微控制器或特定的外部设备。 有多种可能的硬件配置，以及使用这些硬件设置所需的专用操作系统或 IDE。

这本书的目标是让每个人开始学习嵌入式系统的编程，而不需要在硬件上投入太多。 这就是为什么大多数配方都是针对在虚拟化 Linux 环境或仿真器中工作的原因。 然而，有些食谱可能需要物理硬件。 这些食谱被设计成可以在树莓 PI 或 Arduino 上运行，这两个平台使用最广泛，价格也不高，相对容易获得。

| **书中介绍的软件/硬件** | **操作系统要求** |
| Docker
([HTTPS：//www.docker.com/products/docker-Desktop](https://www.docker.com/products/docker-desktop)) | 

*   Microsoft Windows 10 专业企业版 6411-13
*   MacOS 10.13 or later
*   Ubuntu Linux 16.04 or later
*   Debian Linux Stretch(9)或 Buster(10)
*   Fedora Linux 30 or later

 |
| QEMU
([https：//www.qemu.org/download/](https://www.qemu.org/download/)) | 

*   Windows 8 or later (32-bit or 64-bit)
*   MacOS 10.7 or later
*   Linux (various distributions)

 |
| 覆盆子 PI 3 型 B+ |  |
| Arduino UNO R3 或 ELEGOO UNO R3 |  |

**如果您使用的是本书的数字版本，我们建议您自己键入代码或通过 GitHub 存储库(下一节提供的链接)访问代码。 这样做可以帮助您避免与复制和粘贴代码相关的任何潜在错误。**

# 下载示例代码文件

您可以从您的帐户[www.Packt.com](http://www.packt.com/)下载本书的示例代码文件。 如果您在其他地方购买了本书，您可以访问[www.Packtpub.com/support](https://www.packtpub.com/support)并注册，让文件直接通过电子邮件发送给您。

您可以通过以下步骤下载代码文件：

1.  登录或注册[www.Packt.com](http://www.packt.com/)。
2.  选择支持选项卡。
3.  单击 Code Downloads(代码下载)。
4.  在搜索框中输入图书名称，然后按照屏幕上的说明进行操作。

下载文件后，请确保使用以下最新版本解压缩或解压缩该文件夹：

*   WinRar/7-用于 Windows 的 Zip
*   适用于 Mac 的 Zipeg/iZip/UnRarX
*   Linux 版 7-Zip/PeaZip

该书的代码包也托管在 giHub 的[https://github.com/PacktPublishing/Embedded-Programming-with-Modern-CPP-Cookbook](https://github.com/PacktPublishing/Embedded-Programming-with-Modern-CPP-Cookbook)上。 如果代码有更新，它将在现有的 GitHub 存储库中进行更新。

我们还在**[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)**上提供了丰富的图书和视频目录中的其他代码包。 看看他们！

# 下载彩色图像

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图像。 您可以在此处下载：[https://static.packt-cdn.com/downloads/9781838821043_ColorImages.pdf](https://static.packt-cdn.com/downloads/9781838821043_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：指示文本中的代码字、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。 下面是一个示例：“在`gdbserver`下运行`hello`应用。”

代码块设置如下：

```cpp
#include <iostream>

int main() {
 std::cout << "Hello, world!" << std::endl;
 return 0;
}
```

当我们希望您注意代码块的特定部分时，相关行或项将以粗体显示：

```cpp
#include <iostream>

int main() {
 std::cout << "Hello, world!" << std::endl;
 return 0;
}
```

任何命令行输入或输出都如下所示：

```cpp
$ docker run -ti -v $HOME/test:/mnt ubuntu:bionic
```

**粗体**：表示您在屏幕上看到的新术语、重要单词或单词。 例如，菜单或对话框中的单词显示在文本中，如下所示。 下面是一个例子：“为 CMake 配置交叉编译的最佳方式是使用所谓的**工具链**文件。”

Warnings or important notes appear like this. Tips and tricks appear like this.

# 部分 / 派别 / 部门 / 章节

在本书中，您可以找到几个频繁出现的标题(*正在准备*、*如何做……。* ，*它是如何工作的.。* ，*还有更多...。* 和*，另见*)。

要给出关于如何完成食谱的明确说明，请使用以下部分：

# 正在做好准备

本节告诉您食谱中的预期内容，并介绍如何设置食谱所需的任何软件或任何初步设置。

# How to do it…(如何做到这一点)

本节包含遵循食谱所需的步骤。

# 工作原理…

这一节通常包含对上一节中发生的事情的详细解释。

# 还有更多的…

本部分包含有关食谱的其他信息，以便您更好地了解食谱。

# 另请参阅

本节提供了有关食谱的其他有用信息的有用链接。

# 保持联系

欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请在邮件主题中提及书名，并向我们发送电子邮件至`customercare@packtpub.com`。

**勘误表**：虽然我们已经竭尽全力确保内容的准确性，但错误还是会发生。 如果您在这本书中发现了错误，请向我们报告，我们将不胜感激。 请访问[www.Packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择您的图书，单击勘误表提交表链接，然后输入详细信息。

**盗版**：如果您在互联网上遇到任何形式的非法复制我们的作品，请您提供地址或网站名称，我们将不胜感激。 请拨打`copyright@packt.com`与我们联系，并提供该材料的链接。

**如果您有兴趣成为一名作者**：如果有一个您擅长的主题，并且您有兴趣撰写或投稿一本书，请访问[Auths.Packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下评论。 一旦你阅读并使用了这本书，为什么不在你购买它的网站上留下评论呢？ 这样，潜在读者就可以看到并使用您不偏不倚的意见来做出购买决定，我们 Packt 可以了解您对我们产品的看法，我们的作者也可以看到您对他们的书的反馈。 谢谢!

有关 Packt 的更多信息，请访问[Packt.com](http://www.packt.com/)。